\chapter{Google Optimierung}

\section{Duplicate Content vermeiden}
Durch den Einsatz von Flask als Webframework haben wir volle Kontrolle über
die Festlegung einzelner URLs. Die Definition einer View-Funktion erfordert die
Angabe einer URL. Doppelte URLs sind in Flask nicht erlaubt. Innerhalb der
Templates ist dabei nur eine Referenzierung dieser URL via der \emph{url\_for}
Funktion möglich. Es folgt ein Beispiel für eine View Funktion, und ein Fragment
eines Templates:
\\
\\
\begin{verbatim}
    # File: app.py
    # Aufruf bei GET www.moosr.org/search
    @app.route('/search')
    def view_search_page():
        return render_template('search.html')

    --------------- HIER KNICKEN -----------------

    <!-- File: search.html -->
    <!-- {{ Text }} wird durch Template Engine ersetzt -->
    <a href="{{ url_for('view_search_page') }}">Link to Search Page</a>
    <!-- ... -->
\end{verbatim}

Durch die konstante Festlegung und dem konsistenten Zugriff wird effektiv
externer Duplicate Content vermieden. 
\\
\\
Um internen Duplicate Content zu vermeiden wird als Leitlinie stets zwischen
Beiträgen verlinkt. Texte zu kopieren ist verboten. Desweiteren ist auf unserer 
Seite ohnehin der Content jeweils unabhängig voneinander.
\\
Der einzige Fall in dem Interner Duplikat Content vorkommt ist die verkürzte
Blogansicht, bei der nur ein Teaser des Blogeintrags vorhanden ist. Die
Blogübersicht ist allerdings mittels des meta-Tags aus der Indexierung
ausgenommen. Der Link zu den eigentlichen Einträgen wird hingegen befolgt!

\begin{verbatim}
    <meta name="robots" content="noindex, follow, noarchive">
\end{verbatim}

\section{Content Seiten über Navigation erreichbar}

\paragraph{,,Punkt-Punkt-Punkt-Problem''}
Wir haben keine Seite bei der eine Unterteilung in Subseiten zwingend notwendig
ist. Für eine nähere Begründung siehe Punkt \ref{Content_Strecken}.

\paragraph{,,Seite zurück/Seite vor''-Problem}
Um zu vermeiden dass ältere Artikel ein schlechteres Ranking bekommen als neue
Artikel werden Links zu alten Artikeln in einem Archiv ,,aufbewahrt'', welches
wiederum auf der Blogübersicht verlinkt ist.


\label{Content_Strecken}
\section{Artikel über mehrere Seiten strecken}
Aus Gründen der Usability haben wir auf den Punkt verzichtet. Unsere Blogposts
werden in der Übersicht nur mittels eines \emph{Teasers} gezeigt, bei dem auf
eine Detailansicht verlinkt ist. Zudem verlinken wir innerhalb des Archives auf
alle Blogposts. 
\\
\\
Momentan wächst die Postübersicht bis ins theoretisch ,,unendliche'' an.
Unsere Seite bietet sonst kein Content an der sich auf mehrere Seiten ausbreiten
ließe. Zudem empfiehlt Google selbst im Namen der Usability darauf zu
verzichten:
TODO: Link fehlt


\section{Festlegbare Linktexte}
Dieses Verhalten wurde vollkommen implementiert. Siehe hier  zu folgenden
Screenshot:

Beispielsweise kann man bei Blogeinträgen einen langen und einen kurzen Titel
bestimmen. Der lange Titel wird als Überschrift für die Detailansicht und für
die Blogübersicht benutzt. Der kurze Titel wird in der Url und innerhalb von den
Link-Texten benutzt. 
\\
\\
Unwichtige Seiten wie beispielsweise das Impressum haben im Headtag ein Metatag
stehen:
\begin{verbatim}
    <meta name="robots" content="noindex, follow, noarchive">
\end{verbatim}
Dadurch werden diese vom Indizieren ausgenommen, die darin enthaltenen Links
werden aber dennoch ausgewertet.

\section{Einfache URLs erzeugen}
Unsere URL-Struktur basiert auf folgenden Kriterien:
\begin{itemize}
\item Keine Query-Parameter via \emph{?key=value}
\item Beschreiben die Seite kurz und prägnant.
\item Keine IDs in der URLs. Kurze Titel sind zu bevorzugen.
\item Möglichst kurz, ohne viele Zwischenebenen.
\end{itemize}


Beispiele aus unserer URL-Struktur:
\begin{enumerate}
    \item \emph{/blog} Blogübersicht.
    \item \emph{/blog/entry/knorkator} Blogeintrag mit dem Kurztitel ,,Knorkator.''
          Der tatsächliche Name des Eintrags ist dabei länger. Der kurze Titel
          eignet sich für Linktexte und als Bestandteil der URL.
    \item \emph{/developers}, \emph{/about-us} Statische Contentseite.
    \item \emph{/search} Dynamische Metadatensuchseite.
    \item \emph{/query/artistphoto/1/Avril\%20Lavigne} Anzeige der Suchresultate
    eines Künstlerbildes von Avril Lavigne.
    \item \emph{/api/artistphoto/1/Avril\%20Lavigne} Wie oben, aber Anzeige
    eines JSON Dokuments, statt einer HTML Repräsentation.
\end{enumerate}

\section{Editierbare Metadaten}
Jeder Blogeintrag hat einen definierten langen Titel, einen kurzen, prägnanten
Titel der für Linktexte und URLs eingesetzt werden kann, sowie einige Meta-Tags:


Statische Seiten haben ähnliche Attribute, haben allerdings keinen kurzen Titel.
Ein Beispiel:

\begin{verbatim}
    <!-- Kurzbeschreibung der Seite -->
    <meta name="description" content="Guide for API Usage" />
    <!-- Keywords innerhalb des Contents -->
    <meta name="keywords" content="API, Manual, Reference, Metadata, Developer" />
    <!-- Erlaube ausdrücklich Indizierung -->
    <meta name="robots" content="all"/>
\end{verbatim}




Wir haben der Abgabe wie gewünscht einige statische Seiten beigepackt anhand denen sie SEO
validieren können.
